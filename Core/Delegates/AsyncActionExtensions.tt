<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ include file="ActionFuncUtility.tt" once="true" #>

//----------------------------------------------------------------------------------------------------
// <auto-generated> 
//     This code was generated by a T4 template: <#= Path.GetFileName(Host.TemplateFile) #>
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
// </auto-generated> 
//----------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace DogmaMix.Core.Extensions
{
    /// <summary>
    /// Provides extension methods for asynchronous action delegates 
    /// (<see cref="Func{Task}"/>, <see cref="Func{T, Task}"/>, <see cref="Func{T1, T2, Task}"/>, <see cref="Func{T1, T2, T3, Task}"/>, …).
    /// </summary>
    public static class AsyncActionExtensions
    {
<#
    var funcDelegates = GetFuncDelegates();
    foreach (var func in funcDelegates)
    {
#>
        /// <summary>
        /// Creates an asynchronous function delegate that executes the specified asynchronous action delegate 
        /// and returns the specified result upon completion.
        /// </summary>
<#
        WriteTypeParamDoc(func);
#>
        /// <param name="asyncAction">The asynchronous action delegate to be executed by the asynchronous function delegate.</param>
        /// <param name="result">The result that the asynchronous function delegate will return.</param>
        /// <returns>The asynchronous function delegate encapsulating <paramref name="asyncAction"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="asyncAction"/> is <see langword="null"/>.</exception>
<#
        if (func.GenericTypeParameters.Length == 1)
        {
#>
        /// <remarks>
        /// <para>
        /// This method does not immediately execute the <paramref name="asyncAction"/> delegate.
        /// Rather, <paramref name="asyncAction"/> is encapsulated within an asynchronous function delegate,
        /// and will be executed when the latter is invoked.
        /// In the case of an unhandled exception thrown by <paramref name="asyncAction"/>,
        /// the exception is propagated to the caller of the asynchronous function delegate;
        /// <paramref name="result"/> would not be returned.
        /// </para>
        /// <para>
        /// This implementation in based on the <see href="http://stackoverflow.com/a/35633989/1149773">answer by Jon Skeet</see>.
        /// Exceptions that are thrown synchronously from the asynchronous action delegate
        /// will still get delivered synchronously from the asynchronous function delegate.
        /// To get exceptions delivered asynchronously through the returned <see cref="Task{TResult}"/>, use the 
        /// <see cref="AsyncActionExtensions.DeliverAsync(Func{Task})"/> extension method on the created delegate.
        /// </para>
        /// <list type="bullet">
        /// <listheader>See Also</listheader>
        /// <item><see href="http://stackoverflow.com/q/35633615/1149773">Convert asynchronous action to asynchronous function delegate, preserving synchronous exception delivery</see>, <i>Stack Overflow</i></item>
        /// </list>
        /// </remarks>
<#
        }
        else
        {
#>
        /// <remarks>
        /// Refer to the remarks on the <see cref="ReturnAsync{TResult}(Func{Task}, TResult)"/> overload.
        /// </remarks>
<#
        }
#>
        public static Func<#=ConcatTypeParameters(func, result => "Task<" + result + ">")#> ReturnAsync<#=ConcatTypeParameters(func)#>(this Func<#=ConcatTypeParameters(func, result => "Task")#> asyncAction, TResult result)
        {
            ArgumentValidate.NotNull(asyncAction, nameof(asyncAction));
                        
            return (<#=ConcatInvokeParameters(func)#>) =>
            {
                // Invoke asynchronous operation from synchronous part of wrapper.
                // This ensures that synchronous exceptions still get delivered synchronously. 
                var task = asyncAction(<#=ConcatInvokeArguments(func)#>);

                // Then create asynchronous wrapper to await the asynchronous operation and return the result.
                Func<Task<TResult>> asyncFunc = async () =>
                {
                    await task.ConfigureAwait(false);
                    return result;
                };

                return asyncFunc();
            };
        }

        /// <summary>
        /// Transforms the asynchronous action delegate to deliver all exceptions asynchronously, 
        /// through the returned <see cref="Task"/>.
        /// This includes exceptions thrown from the synchronous part of the original asynchronous delegate,
        /// which would otherwise be thrown directly to the caller as soon as the delegate is invoked.
        /// </summary>
<#
        WriteTypeParamDoc(func, includeResult: false);
#>
        /// <param name="asyncAction">The asynchronous action delegate to be transformed.</param>
        /// <returns>The asynchronous action delegate encapsulating <paramref name="asyncAction"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="asyncAction"/> is <see langword="null"/>.</exception>
<#
        if (func.GenericTypeParameters.Length == 1)
        {
#>
        /// <remarks>
        /// <para>
        /// This extension method is useful when one requires all exceptions to be delivered consistently through the returned task.
        /// The point where exceptions get thrown makes a difference if the task is not being awaited immediately.
        /// Consider the following code:
        /// </para>
        /// <code>
        /// public async Task TestMethod()
        /// {
        ///     Task task = WriteAllBytesAsync(null, null);   // ArgumentNullException thrown here
        ///     // do more processing
        ///     await task;                                   // asynchronous exceptions thrown here
        /// }
        /// 
        /// public static Task WriteAllBytesAsync(string filePath, byte[] bytes)
        /// {
        ///     if (filePath == null)
        ///         throw new ArgumentNullException(filePath, nameof(filePath));
        ///     if (bytes == null)
        ///         throw new ArgumentNullException(filePath, nameof(bytes));
        /// 
        ///     return WriteAllBytesAsyncInner(filePath, bytes);
        /// }
        /// 
        /// private static async Task WriteAllBytesAsyncInner(string filePath, byte[] bytes)
        /// {
        ///     using (var fileStream = File.OpenWrite(filePath))
        ///         await fileStream.WriteAsync(bytes, 0, bytes.Length);
        /// }
        /// </code>
        /// <para>
        /// Since synchronous exceptions typically involve precondition check failures, 
        /// it is usually desirable for them to be delivered synchronously.
        /// Whenever it is not, this extension method may be used.
        /// </para>
        /// <list type="bullet">
        /// <listheader>See Also</listheader>
        /// <item><see href="http://stackoverflow.com/q/21661511/1149773">Contract agreement when implementing a method that returns a Task</see>, <i>Stack Overflow</i></item>
        /// <item><see href="http://stackoverflow.com/q/21055920/1149773">Handling exceptions from the synchronous part of async method</see>, <i>Stack Overflow</i></item>
        /// <item><see href="http://stackoverflow.com/q/35633615/1149773">Convert asynchronous action to asynchronous function delegate preserving synchronous exception delivery</see>, <i>Stack Overflow</i></item>
        /// </list>
        /// </remarks>
<#
        }
        else
        {
#>
        /// <remarks>
        /// Refer to the remarks on the <see cref="DeliverAsync(Func{Task})"/> overload.
        /// </remarks>
<#
        }
#>
        public static Func<#=ConcatTypeParameters(func, result => "Task")#> DeliverAsync<#=ConcatTypeParameters(func, result => null)#>(this Func<#=ConcatTypeParameters(func, result => "Task")#> asyncAction)
        {
            ArgumentValidate.NotNull(asyncAction, nameof(asyncAction));
                        
            return async (<#=ConcatInvokeParameters(func)#>) =>
            { 
                await asyncAction(<#=ConcatInvokeArguments(func)#>).ConfigureAwait(false);
            };
        }

<#
    }
#>
    }
}
