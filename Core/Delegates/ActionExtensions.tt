<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ include file="ActionFuncUtility.tt" once="true" #>

//----------------------------------------------------------------------------------------------------
// <auto-generated> 
//     This code was generated by a T4 template: <#= Path.GetFileName(Host.TemplateFile) #>
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
// </auto-generated> 
//----------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace DogmaMix.Core.Extensions
{
    /// <summary>
    /// Provides extension methods for action delegates 
    /// (<see cref="Action"/>, <see cref="Action{T}"/>, <see cref="Action{T1, T2}"/>, <see cref="Action{T1, T2, T3}"/>, …).
    /// </summary>
    public static class ActionExtensions
    {
<#
    var actionDelegates = GetActionDelegates();
    foreach (var action in actionDelegates)
    {
#>
        /// <summary>
        /// Creates a function delegate that executes the specified action delegate 
        /// and returns the specified result upon completion.
        /// </summary>
<#
        WriteTypeParamDoc(action);
#>
        /// <typeparam name="TResult">The type of the result that the function delegate will return.</typeparam>
        /// <param name="action">The action delegate to be executed by the function delegate.</param>
        /// <param name="result">The result that the function delegate will return.</param>
        /// <returns>The function delegate encapsulating <paramref name="action"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="action"/> is <see langword="null"/>.</exception>
<#
        if (!action.IsGenericType)
        {
#>
        /// <remarks>
        /// <para>
        /// This method does not immediately execute the <paramref name="action"/> delegate.
        /// Rather, <paramref name="action"/> is encapsulated within a function delegate,
        /// and will be executed when the latter is invoked.
        /// In the case of an unhandled exception thrown by <paramref name="action"/>,
        /// the exception is propagated to the caller of the function delegate;
        /// <paramref name="result"/> would not be returned.
        /// </para>
        /// <para>
        /// This method is convenient when implementing a pair of method overloads for some delegate-based functionality,
        /// with one overload taking an <see cref="Action"/> parameter, and the other a <see cref="Func{TResult}"/>,
        /// such as is the case for <see cref="Task.Run(Action)"/> and <see cref="Task.Run{TResult}(Func{TResult})"/>.
        /// The action overload can be implemented by calling this <see cref="Return{TResult}(Action, TResult)"/> method
        /// on the <see cref="Action"/> argument to convert it to a <see cref="Func{TResult}"/> delegate returning an arbitrary value,
        /// and then passing the created function delegate to the function overload.
        /// </para>
        /// </remarks>
        /// <example>
        /// <code>
        /// public static void DoSomething(Action action)
        /// {
        ///     ArgumentValidate.NotNull(action, nameof(action));
        ///
        ///     DoSomething(action.Return(true));
        /// }
        /// 
        /// public static TResult DoSomething&lt;TResult&gt;(Func&lt;TResult&gt; func)
        /// {
        ///     ArgumentValidate.NotNull(func, nameof(func));
        ///
        ///     // preprocessing
        ///
        ///     try
        ///     {
        ///         return func();
        ///     }
        ///     finally
        ///     {
        ///         // postprocessing
        ///     }
        /// }
        /// </code>
        /// </example>
<#
        }
        else
        {
#>
        /// <remarks>
        /// Refer to the remarks on the <see cref="Return{TResult}(Action, TResult)"/> overload.
        /// </remarks>
<#
        }
#>
        public static Func<#=ConcatTypeParameters(action, "TResult")#> Return<#=ConcatTypeParameters(action, "TResult")#>(this Action<#=ConcatTypeParameters(action)#> action, TResult result)
        {
            ArgumentValidate.NotNull(action, nameof(action));

            return (<#=ConcatInvokeParameters(action)#>) =>
            {
                action(<#=ConcatInvokeArguments(action)#>);
                return result;
            };
        }

        /// <summary>
        /// Creates an asynchronous delegate that executes the specified action delegate synchronously
        /// and returns a task that indicates successful completion (like <see cref="Task.CompletedTask"/>).
        /// </summary>
<#
        WriteTypeParamDoc(action);
#>
        /// <param name="action">The action delegate to be executed synchronously by the asynchronous delegate.</param>
        /// <returns>The asynchronous delegate encapsulating <paramref name="action"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="action"/> is <see langword="null"/>.</exception>
<#
        if (!action.IsGenericType)
        {
#>
        /// <remarks>
        /// <para>
        /// This method does not immediately execute the <paramref name="action"/> delegate.
        /// Rather, <paramref name="action"/> is encapsulated within an asynchronous delegate,
        /// and will be executed when the latter is invoked.
        /// In the case of an unhandled exception thrown by <paramref name="action"/>,
        /// the exception is propagated to the caller of the asynchronous delegate.
        /// </para>
        /// <para>
        /// The asynchronous delegate created by this method is just a <see cref="Task"/>-returning wrapper over the 
        /// <paramref name="action"/> delegate. It <i>does not</i> queue the specified work to run on the thread pool.
        /// For such functionality, use the <see cref="Task.Run(Action)"/> method of the <see cref="Task"/> class.
        /// </para>
        /// <para>
        /// The asynchronous delegate created by this method delivers exceptions synchronously.
        /// This means that, if <paramref name="action"/> throws an unhandled exception, it will be propagated directly to its caller,
        /// and not encapsulated in the returned <see cref="Task"/> (making it <see cref="TaskStatus.Faulted"/>).
        /// To get exceptions delivered asynchronously through the returned <see cref="Task"/>, use the 
        /// <see cref="AsyncActionExtensions.DeliverAsync(Func{Task})"/> extension method on the created delegate.
        /// </para>
        /// <para>
        /// This method is convenient when implementing a pair of method overloads for some delegate-based functionality,
        /// with one overload taking an <see cref="Action"/> parameter, and the other an asynchronous <see cref="Func{Task}"/>,
        /// such as is the case for <see cref="Task.Run(Action)"/> and <see cref="Task.Run(Func{Task})"/>.
        /// The action overload can be implemented by calling this <see cref="WrapAsync(Action)"/> method
        /// on the <see cref="Action"/> argument to convert it to an asynchronous <see cref="Func{Task}"/> delegate 
        /// returning a completed task, and then passing the created delegate to the asynchronous overload.
        /// </para>
        /// </remarks>
        /// <example>
        /// <code>
        /// public static void DoSomething(Action action)
        /// {
        ///     ArgumentValidate.NotNull(action, nameof(action));
        ///
        ///     var asyncFunc = action.WrapAsync();
        ///     var task = DoSomething(asyncFunc);
        ///     task.GetAwaiter().GetResult();   // task is always completed; returns immediately
        /// }
        /// 
        /// public static async Task DoSomething(Func&lt;Task&gt; asyncAction)
        /// {
        ///     ArgumentValidate.NotNull(asyncAction, nameof(asyncAction));
        ///
        ///     // preprocessing
        ///
        ///     try
        ///     {
        ///         await asyncAction().ConfigureAwait(false);
        ///     }
        ///     finally
        ///     {
        ///         // postprocessing
        ///     }
        /// }
        /// </code>
        /// </example>
<#
        }
        else
        {
#>
        /// <remarks>
        /// Refer to the remarks on the <see cref="WrapAsync(Action)"/> overload.
        /// </remarks>
<#
        }
#>
        public static Func<#=ConcatTypeParameters(action, "Task")#> WrapAsync<#=ConcatTypeParameters(action)#>(this Action<#=ConcatTypeParameters(action)#> action)
        {
            ArgumentValidate.NotNull(action, nameof(action));

            return (<#=ConcatInvokeParameters(action)#>) =>
            {
                action(<#=ConcatInvokeArguments(action)#>);
                return Task.CompletedTask;
            };
        }

<#
    }
#>
    }
}
