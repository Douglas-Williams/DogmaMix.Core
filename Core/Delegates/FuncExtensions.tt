<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ include file="ActionFuncUtility.tt" once="true" #>

//----------------------------------------------------------------------------------------------------
// <auto-generated> 
//     This code was generated by a T4 template: <#= Path.GetFileName(Host.TemplateFile) #>
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
// </auto-generated> 
//----------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace DogmaMix.Core.Extensions
{
    /// <summary>
    /// Provides extension methods for function delegates 
    /// (<see cref="Func{TResult}"/>, <see cref="Func{T, TResult}"/>, <see cref="Func{T1, T2, TResult}"/>, <see cref="Func{T1, T2, T3, TResult}"/>, …).
    /// </summary>
    public static class FuncExtensions
    {
<#
    var funcDelegates = GetFuncDelegates();
    foreach (var func in funcDelegates)
    {
#>
        /// <summary>
        /// Creates an asynchronous delegate that executes the specified function delegate synchronously
        /// and returns a task that has completed successfully with the said delegate's result
        /// (like through <see cref="Task.FromResult{TResult}(TResult)"/>).
        /// </summary>
<#
        WriteTypeParamDoc(func);
#>
        /// <param name="func">The function delegate to be executed synchronously by the asynchronous delegate.</param>
        /// <returns>The asynchronous delegate encapsulating <paramref name="func"/>.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="func"/> is <see langword="null"/>.</exception>
<#
        if (func.GenericTypeParameters.Length == 1)
        {
#>
        /// <remarks>
        /// <para>
        /// This method does not immediately execute the <paramref name="func"/> delegate.
        /// Rather, <paramref name="func"/> is encapsulated within an asynchronous delegate,
        /// and will be executed when the latter is invoked.
        /// In the case of an unhandled exception thrown by <paramref name="func"/>,
        /// the exception is propagated to the caller of the asynchronous delegate.
        /// </para>
        /// <para>
        /// The asynchronous delegate created by this method is just a <see cref="Task{TResult}"/>-returning wrapper over the 
        /// <paramref name="func"/> delegate. It <i>does not</i> queue the specified work to run on the thread pool.
        /// For such functionality, use the <see cref="Task.Run{TResult}(Func{TResult})"/> method of the <see cref="Task"/> class.
        /// </para>
        /// <para>
        /// The asynchronous delegate created by this method delivers exceptions synchronously.
        /// This means that, if <paramref name="func"/> throws an unhandled exception, it will be propagated directly to its caller,
        /// and not encapsulated in the returned <see cref="Task{TResult}"/> (making it <see cref="TaskStatus.Faulted"/>).
        /// To get exceptions delivered asynchronously through the returned <see cref="Task{TResult}"/>, use the 
        /// <see cref="AsyncFuncExtensions.DeliverAsync{TResult}(Func{Task{TResult}})"/> extension method on the created delegate.
        /// </para>
        /// <para>
        /// This method is convenient when implementing a pair of method overloads for some delegate-based functionality,
        /// with one overload taking an <see cref="Func{TResult}"/> parameter, and the other an asynchronous 
        /// <see cref="Func{T}"/> of <see cref="Task{TResult}"/>,
        /// such as is the case for <see cref="Task.Run{TResult}(Func{TResult})"/> and <see cref="Task.Run{TResult}(Func{Task{TResult}})"/>.
        /// The function overload can be implemented by calling this <see cref="WrapAsync{TResult}(Func{TResult})"/> method
        /// on the <see cref="Func{TResult}"/> argument to convert it to an asynchronous <see cref="Func{T}"/> of <see cref="Task{TResult}"/>
        /// delegate returning a completed task with the former delegate's result, and then passing the created delegate
        /// to the asynchronous overload.
        /// </para>
        /// </remarks>
        /// <example>
        /// <code>
        /// public static TResult DoSomething&lt;TResult&gt;(Func&lt;TResult&gt; func)
        /// {
        ///     ArgumentValidate.NotNull(func, nameof(func));
        /// 
        ///     var asyncFunc = func.WrapAsync();
        ///     var task = DoSomething(asyncFunc);
        ///     return task.GetAwaiter().GetResult();   // task is always completed; returns immediately
        /// }
        /// 
        /// public static async Task&lt;TResult&gt; DoSomething&lt;TResult&gt;(Func&lt;Task&lt;TResult&gt;&gt; asyncFunc)
        /// {
        ///     ArgumentValidate.NotNull(asyncFunc, nameof(asyncFunc));
        /// 
        ///     // preprocessing
        /// 
        ///     try
        ///     {
        ///         return await asyncFunc().ConfigureAwait(false);
        ///     }
        ///     finally
        ///     {
        ///         // postprocessing
        ///     }
        /// }
        /// </code>
        /// </example>
<#
        }
        else
        {
#>
        /// <remarks>
        /// Refer to the remarks on the <see cref="WrapAsync{TResult}(Func{TResult})"/> overload.
        /// </remarks>
<#
        }
#>
        public static Func<#=ConcatTypeParameters(func, result => "Task<" + result + ">")#> WrapAsync<#=ConcatTypeParameters(func)#>(this Func<#=ConcatTypeParameters(func)#> func)
        {
            ArgumentValidate.NotNull(func, nameof(func));

            return (<#=ConcatInvokeParameters(func)#>) =>
            {
                var result = func(<#=ConcatInvokeArguments(func)#>);
                return Task.FromResult(result);
            };
        }
        
<#
    }
#>
    }
}