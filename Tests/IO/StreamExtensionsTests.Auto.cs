 

//----------------------------------------------------------------------------------------------------
// <auto-generated> 
//     This code was generated by a T4 template: StreamExtensionsTests.Auto.tt
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
// </auto-generated> 
//----------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using DogmaMix.Core.Extensions;
using DogmaMix.Core.IO;
using DogmaMix.Core.Randomization;
using DogmaMix.Core.UnitTesting;

namespace DogmaMix.Core.Extensions.Tests
{
    public partial class StreamExtensionsTests
    {
        [TestMethod]
        public void ReadToEnd_Entire()
        {
            var bytes = new byte[] { 243, 75, 31, 139, 26 };
            using (var stream = new MemoryStream(bytes))
            {
                EnumerableAssert.AreEqual(bytes, stream.ReadToEnd());
                Assert.AreEqual(bytes.Length, stream.Position);
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                EnumerableAssert.AreEqual(bytes, stream.ReadToEnd());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }

        [TestMethod]
        public void ReadToEnd_Partial()
        {
            var bytes = new byte[] { 243, 75, 31, 139, 26, 41, 52, 164, 191, 55, 75, 237 };
            for (int pos = 0; pos < bytes.Length; pos++)
            {
                using (var stream = new MemoryStream(bytes))
                {
                    stream.Seek(pos, SeekOrigin.Begin);
                    EnumerableAssert.AreEqual(bytes.Skip(pos), stream.ReadToEnd());
                    Assert.AreEqual(bytes.Length, stream.Position);
                }
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                int pos = bytes.Length / 3;
                stream.Seek(pos, SeekOrigin.Begin);
                EnumerableAssert.AreEqual(bytes.Skip(pos), stream.ReadToEnd());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }
        
        [TestMethod]
        public void ReadToEnd_Empty()
        {
            using (var stream = new MemoryStream())
            {
                EnumerableAssert.IsEmpty(stream.ReadToEnd());
                Assert.AreEqual(0, stream.Position);
            }

            var bytes = new byte[] { 243, 75, 31, 139, 26 };
            using (var stream = new MemoryStream(bytes))
            {
                stream.Seek(0, SeekOrigin.End);
                EnumerableAssert.IsEmpty(stream.ReadToEnd());
                Assert.AreEqual(bytes.Length, stream.Position);
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                stream.Seek(0, SeekOrigin.End);
                EnumerableAssert.IsEmpty(stream.ReadToEnd());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }
        
        [TestMethod]
        public void ReadToEnd_FileStream()
        {
            using (var tempFile = new TempFile(create: false))
            {
                var filePath = tempFile.FilePath;
                var bytes = CachedRandom.Current.NextBytes(16 * 1024);
                File.WriteAllBytes(filePath, bytes);

                using (var fileStream = File.OpenRead(filePath))
                {
                    EnumerableAssert.AreEqual(bytes, fileStream.ReadToEnd());
                }

                using (var fileStream = File.OpenRead(filePath))
                {
                    byte[] discard = new byte[4 * 1024];
                    int discarded = fileStream.Read(discard, 0, discard.Length);

                    EnumerableAssert.AreEqual(bytes.Skip(discarded), fileStream.ReadToEnd());
                }
            }
        }

        [TestMethod]
        public async Task ReadToEndAsync_Entire()
        {
            var bytes = new byte[] { 243, 75, 31, 139, 26 };
            using (var stream = new MemoryStream(bytes))
            {
                EnumerableAssert.AreEqual(bytes, await stream.ReadToEndAsync());
                Assert.AreEqual(bytes.Length, stream.Position);
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                EnumerableAssert.AreEqual(bytes, await stream.ReadToEndAsync());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }

        [TestMethod]
        public async Task ReadToEndAsync_Partial()
        {
            var bytes = new byte[] { 243, 75, 31, 139, 26, 41, 52, 164, 191, 55, 75, 237 };
            for (int pos = 0; pos < bytes.Length; pos++)
            {
                using (var stream = new MemoryStream(bytes))
                {
                    stream.Seek(pos, SeekOrigin.Begin);
                    EnumerableAssert.AreEqual(bytes.Skip(pos), await stream.ReadToEndAsync());
                    Assert.AreEqual(bytes.Length, stream.Position);
                }
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                int pos = bytes.Length / 3;
                stream.Seek(pos, SeekOrigin.Begin);
                EnumerableAssert.AreEqual(bytes.Skip(pos), await stream.ReadToEndAsync());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }
        
        [TestMethod]
        public async Task ReadToEndAsync_Empty()
        {
            using (var stream = new MemoryStream())
            {
                EnumerableAssert.IsEmpty(await stream.ReadToEndAsync());
                Assert.AreEqual(0, stream.Position);
            }

            var bytes = new byte[] { 243, 75, 31, 139, 26 };
            using (var stream = new MemoryStream(bytes))
            {
                stream.Seek(0, SeekOrigin.End);
                EnumerableAssert.IsEmpty(await stream.ReadToEndAsync());
                Assert.AreEqual(bytes.Length, stream.Position);
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                stream.Seek(0, SeekOrigin.End);
                EnumerableAssert.IsEmpty(await stream.ReadToEndAsync());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }
        
        [TestMethod]
        public async Task ReadToEndAsync_FileStream()
        {
            using (var tempFile = new TempFile(create: false))
            {
                var filePath = tempFile.FilePath;
                var bytes = CachedRandom.Current.NextBytes(16 * 1024);
                File.WriteAllBytes(filePath, bytes);

                using (var fileStream = File.OpenRead(filePath))
                {
                    EnumerableAssert.AreEqual(bytes, await fileStream.ReadToEndAsync());
                }

                using (var fileStream = File.OpenRead(filePath))
                {
                    byte[] discard = new byte[4 * 1024];
                    int discarded = await fileStream.ReadAsync(discard, 0, discard.Length);

                    EnumerableAssert.AreEqual(bytes.Skip(discarded), await fileStream.ReadToEndAsync());
                }
            }
        }

    }
}