<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>

//----------------------------------------------------------------------------------------------------
// <auto-generated> 
//     This code was generated by a T4 template: <#= Path.GetFileName(Host.TemplateFile) #>
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
// </auto-generated> 
//----------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using DogmaMix.Core.Extensions;
using DogmaMix.Core.IO;
using DogmaMix.Core.Randomization;
using DogmaMix.Core.UnitTesting;

namespace DogmaMix.Core.Extensions.Tests
{
    public partial class StreamExtensionsTests
    {
<#
    foreach (bool isAsync in new [] { false, true })
    {
        var returnSignature = isAsync ? "async Task" : "void";
        var asyncStr = isAsync ? "Async" : "";
        var awaitStr = isAsync ? "await " : "";
#>
        [TestMethod]
        public <#=returnSignature#> ReadToEnd<#=asyncStr#>_Entire()
        {
            var bytes = new byte[] { 243, 75, 31, 139, 26 };
            using (var stream = new MemoryStream(bytes))
            {
                EnumerableAssert.AreEqual(bytes, <#=awaitStr#>stream.ReadToEnd<#=asyncStr#>());
                Assert.AreEqual(bytes.Length, stream.Position);
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                EnumerableAssert.AreEqual(bytes, <#=awaitStr#>stream.ReadToEnd<#=asyncStr#>());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }

        [TestMethod]
        public <#=returnSignature#> ReadToEnd<#=asyncStr#>_Partial()
        {
            var bytes = new byte[] { 243, 75, 31, 139, 26, 41, 52, 164, 191, 55, 75, 237 };
            for (int pos = 0; pos < bytes.Length; pos++)
            {
                using (var stream = new MemoryStream(bytes))
                {
                    stream.Seek(pos, SeekOrigin.Begin);
                    EnumerableAssert.AreEqual(bytes.Skip(pos), <#=awaitStr#>stream.ReadToEnd<#=asyncStr#>());
                    Assert.AreEqual(bytes.Length, stream.Position);
                }
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                int pos = bytes.Length / 3;
                stream.Seek(pos, SeekOrigin.Begin);
                EnumerableAssert.AreEqual(bytes.Skip(pos), <#=awaitStr#>stream.ReadToEnd<#=asyncStr#>());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }
        
        [TestMethod]
        public <#=returnSignature#> ReadToEnd<#=asyncStr#>_Empty()
        {
            using (var stream = new MemoryStream())
            {
                EnumerableAssert.IsEmpty(<#=awaitStr#>stream.ReadToEnd<#=asyncStr#>());
                Assert.AreEqual(0, stream.Position);
            }

            var bytes = new byte[] { 243, 75, 31, 139, 26 };
            using (var stream = new MemoryStream(bytes))
            {
                stream.Seek(0, SeekOrigin.End);
                EnumerableAssert.IsEmpty(<#=awaitStr#>stream.ReadToEnd<#=asyncStr#>());
                Assert.AreEqual(bytes.Length, stream.Position);
            }

            bytes = CachedRandom.Current.NextBytes(4 * 1024 * 1024);
            using (var stream = new MemoryStream(bytes))
            {
                stream.Seek(0, SeekOrigin.End);
                EnumerableAssert.IsEmpty(<#=awaitStr#>stream.ReadToEnd<#=asyncStr#>());
                Assert.AreEqual(bytes.Length, stream.Position);
            }
        }
        
        [TestMethod]
        public <#=returnSignature#> ReadToEnd<#=asyncStr#>_FileStream()
        {
            using (var tempFile = new TempFile(create: false))
            {
                var filePath = tempFile.FilePath;
                var bytes = CachedRandom.Current.NextBytes(16 * 1024);
                File.WriteAllBytes(filePath, bytes);

                using (var fileStream = File.OpenRead(filePath))
                {
                    EnumerableAssert.AreEqual(bytes, <#=awaitStr#>fileStream.ReadToEnd<#=asyncStr#>());
                }

                using (var fileStream = File.OpenRead(filePath))
                {
                    byte[] discard = new byte[4 * 1024];
                    int discarded = <#=awaitStr#>fileStream.Read<#=asyncStr#>(discard, 0, discard.Length);

                    EnumerableAssert.AreEqual(bytes.Skip(discarded), <#=awaitStr#>fileStream.ReadToEnd<#=asyncStr#>());
                }
            }
        }

<#
    }
#>
    }
}