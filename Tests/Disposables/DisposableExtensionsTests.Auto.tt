<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>

//----------------------------------------------------------------------------------------------------
// <auto-generated> 
//     This code was generated by a T4 template: <#= Path.GetFileName(Host.TemplateFile) #>
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
// </auto-generated> 
//----------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using DogmaMix.Core.Disposables;
using DogmaMix.Core.Types;
using DogmaMix.Core.UnitTesting;

namespace DogmaMix.Core.Extensions.Tests
{
    public partial class DisposableExtensionsTests
    {
<#
    foreach (bool isAsync in new [] { false, true })
    {
        var returnSignature = isAsync ? "async Task" : "void";
        var asyncStr = isAsync ? "Async" : "";
        var awaitStr = isAsync ? "await " : "";
        var asyncMod = isAsync ? "async " : "";
#>
        [TestMethod]
        public <#=returnSignature#> Using<#=asyncStr#>()
        {
            bool throwMain = false;
            bool throwDispose = false;
            foreach (var strategy in EnumUtility.GetValues<DisposeExceptionStrategy>())
                <#=awaitStr#>TestStrategyNoException<#=asyncStr#>(strategy, throwMain, throwDispose);

            throwMain = true;
            throwDispose = false;
            <#=awaitStr#>TestStrategy<#=asyncStr#><MainLogicException>(DisposeExceptionStrategy.Propagate, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><MainLogicException>(DisposeExceptionStrategy.Swallow, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><MainLogicException>(DisposeExceptionStrategy.Subjugate, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><MainLogicException>(DisposeExceptionStrategy.AggregateMultiple, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><AggregateException>(DisposeExceptionStrategy.AggregateAlways, throwMain, throwDispose, e =>
                Assert.IsInstanceOfType(e.InnerExceptions.Single(), typeof(MainLogicException)));

            throwMain = false;
            throwDispose = true;
            <#=awaitStr#>TestStrategy<#=asyncStr#><DisposeException>(DisposeExceptionStrategy.Propagate, throwMain, throwDispose);
            <#=awaitStr#>TestStrategyNoException<#=asyncStr#>(DisposeExceptionStrategy.Swallow, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><DisposeException>(DisposeExceptionStrategy.Subjugate, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><DisposeException>(DisposeExceptionStrategy.AggregateMultiple, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><AggregateException>(DisposeExceptionStrategy.AggregateAlways, throwMain, throwDispose, e =>
                Assert.IsInstanceOfType(e.InnerExceptions.Single(), typeof(DisposeException)));

            throwMain = true;
            throwDispose = true;
            <#=awaitStr#>TestStrategy<#=asyncStr#><DisposeException>(DisposeExceptionStrategy.Propagate, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><MainLogicException>(DisposeExceptionStrategy.Swallow, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><MainLogicException>(DisposeExceptionStrategy.Subjugate, throwMain, throwDispose);
            <#=awaitStr#>TestStrategy<#=asyncStr#><AggregateException>(DisposeExceptionStrategy.AggregateMultiple, throwMain, throwDispose, e =>
            {
                EnumerableAssert.HasCount(2, e.InnerExceptions);
                Assert.IsInstanceOfType(e.InnerExceptions[0], typeof(MainLogicException));
                Assert.IsInstanceOfType(e.InnerExceptions[1], typeof(DisposeException));
            });
            <#=awaitStr#>TestStrategy<#=asyncStr#><AggregateException>(DisposeExceptionStrategy.AggregateAlways, throwMain, throwDispose, e =>
            {
                EnumerableAssert.HasCount(2, e.InnerExceptions);
                Assert.IsInstanceOfType(e.InnerExceptions[0], typeof(MainLogicException));
                Assert.IsInstanceOfType(e.InnerExceptions[1], typeof(DisposeException));
            });
        }

        private static <#=returnSignature#> TestStrategyNoException<#=asyncStr#>(DisposeExceptionStrategy strategy, bool throwMain, bool throwDispose)
        {
            // No return value:

            var disposable = new SampleDisposable(throwDispose);

            <#=awaitStr#>disposable.Using<#=asyncStr#>(strategy, <#=asyncMod#>_ => <#=awaitStr#>RunMainLogic<#=asyncStr#>(throwMain));

            Assert.IsTrue(disposable.WasDisposeCalled);

            // With return value:

            disposable = new SampleDisposable(throwDispose);

            var result = <#=awaitStr#>disposable.Using<#=asyncStr#>(strategy, <#=asyncMod#>_ => 
            {
                <#=awaitStr#>RunMainLogic<#=asyncStr#>(throwMain);
                return 42;
            });

            Assert.IsTrue(disposable.WasDisposeCalled);
            Assert.AreEqual(42, result);
        }

        private static <#=returnSignature#> TestStrategy<#=asyncStr#><TException>(DisposeExceptionStrategy strategy, bool throwMain, bool throwDispose, Action<TException> exceptionVerify = null)
            where TException : Exception
        {
            // No return value:

            var disposable = new SampleDisposable(throwDispose);

            var exception = <#=awaitStr#>ExceptionAssert.Throws<#=asyncStr#><TException>(() =>
                disposable.Using<#=asyncStr#>(strategy, <#=asyncMod#>_ => <#=awaitStr#>RunMainLogic<#=asyncStr#>(throwMain)));

            Assert.IsTrue(disposable.WasDisposeCalled);
            exceptionVerify?.Invoke(exception);

            // With return value:

            disposable = new SampleDisposable(throwDispose);

            exception = <#=awaitStr#>ExceptionAssert.Throws<#=asyncStr#><TException>(() =>
                disposable.Using<#=asyncStr#>(strategy, <#=asyncMod#>_ => 
                {
                    <#=awaitStr#>RunMainLogic<#=asyncStr#>(throwMain);
                    return 42;
                }));

            Assert.IsTrue(disposable.WasDisposeCalled);
            exceptionVerify?.Invoke(exception);
        }
        
#pragma warning disable 1998
        private static <#=returnSignature#> RunMainLogic<#=asyncStr#>(bool throwMain = false)
        {
            if (throwMain)
                throw new MainLogicException();
        }
#pragma warning restore 1998

<#
    }
#>    
    }
}