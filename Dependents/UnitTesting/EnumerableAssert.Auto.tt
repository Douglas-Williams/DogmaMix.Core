<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Microsoft.VisualStudio.TestTools.UnitTesting" #>

//----------------------------------------------------------------------------------------------------
// <auto-generated> 
//     This code was generated by a T4 template: <#= Path.GetFileName(Host.TemplateFile) #>
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. 
// </auto-generated> 
//----------------------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace DogmaMix.Core.UnitTesting
{
    public static partial class EnumerableAssert
    {
<#
    foreach (var method in typeof(CollectionAssert).GetMethods(BindingFlags.Public | BindingFlags.Static))
    {
        if (method.ReturnType != typeof(void))
            continue;

        var parameters = method.GetParameters();
        var parametersOriginal = string.Join(",", parameters.Select(p => p.ParameterType.Name));
        var parametersWrapper = string.Join(", ", parameters.Select(p => TransformParameterType(p) + " " + TransformParameterName(p)));
        var argumentsTransform = string.Join(", ", parameters.Select(p => TransformArgument(p)));

#>
        /// <summary>
        /// Wrapper for the <see cref="CollectionAssert.<#=method.Name#>(<#=parametersOriginal#>)"/> method.
        /// </summary>
        public static void <#=method.Name#><T>(<#=parametersWrapper#>)
        {
            CollectionAssert.<#=method.Name#>(<#=argumentsTransform#>);
        }

<#
    }
#>
        /// <summary>
        /// Wraps an <see cref="IComparer{T}"/> instance such that it can be accessed through 
        /// the non-generic <see cref="IComparer"/> interface.
        /// </summary>
        private sealed class ComparerWrapper<T> : Comparer<T>
        {
            private IComparer<T> _comparer;

            public static ComparerWrapper<T> Create(IComparer<T> comparer)
            {
                // Let nulls be handled by the CollectionAssert class.
                if (comparer == null)
                    return null;

                var wrapper = new ComparerWrapper<T>();
                wrapper._comparer = comparer;
                return wrapper;
            }

            public override int Compare(T x, T y)
            {
                return _comparer.Compare(x, y);
            }
        }
    }
}
 
<#+
private static string TransformParameterType(ParameterInfo p)
{
    return
        p.ParameterType == typeof(ICollection) ? "IEnumerable<T>" : 
        p.ParameterType == typeof(IComparer) ? "IComparer<T>" : 
        p.ParameterType == typeof(Object) && p.Name == "element" ? "T" : 
        p.ParameterType.Name;
}

private static string TransformParameterName(ParameterInfo p)
{
    return
        p.ParameterType == typeof(ICollection) ? 
        p.Name.Replace("collection", "sequence") : 
        p.Name;
}

private static string TransformArgument(ParameterInfo p)
{
    string parameterName = TransformParameterName(p);

    return
        p.ParameterType == typeof(ICollection) ? parameterName + "?.ToList()" : 
        p.ParameterType == typeof(IComparer) ? "ComparerWrapper<T>.Create(" + parameterName + ")" : 
        parameterName;
}
#>